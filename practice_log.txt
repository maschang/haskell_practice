20170804

Install したい。
とりあえず公式サイト見よう。
https://www.haskell.org/
Mac用のインストールガイドあった。
Homebrewあった。
https://www.haskell.org/platform/mac.html#osx-homebrewcask
`brew cask install haskell-platform`
入った。
とりあえず、対話モードで起動してみよう。
`ghci`打てばいいのか。
うまくいった。
とりあえず、「すごいHaskell」の1章読んでみる。

メモ
# はじめの一歩

## 1 − 1〜2
- プロンプトにこだわりあれば `:set prompt "ghci>"`って打つ。面倒であれば.ghci ファイルに書き込んどけば起動時に読み込む。
- 負の数は()でくくる
- 四則演算や論理演算は普通見たまま。同値演算は`==` `/=`
- 四則演算は中置演算と呼ばれるらしい。普通は前置演算。`succ 2` 3
- 関数呼び出しには優先順位があるらしい。慣れが若干必要かも
- 関数の定義は = で結ぶ。`doubleMe x = x + x`
- ファイルをghciを立ち上げたディレクトリに .hs とかで保存して :l ファイル名で呼び出せばできる。
- コメントアウトは -- で！
- Haskellにおいてif文ではelseが必須らしい。ほえ〜。
  - 関数の全ては何かしらの値を返却する。戻り値がある。なのでif文で必ずelseがあれば戻り値を期待できる。ほえ〜。
- アポストロフィは特別な意味を持たない関数名の一部として有効
- 関数名は大文字始まりは禁止。

## 1 - 3
- 数値と文字列の混合のリストは作れない。
- 変数の定義には `let` を使う。
- リストの連結操作や文字列の結合は `++` を使う。
- 文字列は内部的に文字列のリスト扱いに鳴っているのでリスト関数が文字列に適用できて便利。ほえ〜。
  - なので、文字列リスト同士の結合の戻り値は文字列で返ってくる。`['w', 'o'] ++ ['o', 'd']` => 'wood'
  - 但し、長い文字列を結合する場合とかは全リストを走査するので時間がかかる。先頭に追加するとかの処理の場合はcons演算子（:）を使う。
    - 'A':" SMALL CAT" => 'A SMALL CAT'
    - 5:[1,2,3] => [5,1,2,3]
- Haskellは遅延評価
- リストへのアクセスは `!!` 演算子を使う。
  - リストの操作 head, tail（最初の要素を取り除いた残りのリスト）, last, init(最後の要素を取り除いた残りのリスト)
  - length, null(空のリストかチェックしてbool値を返す), reverse, take(先頭から指定された数取り出す), drop(指定された数の要素を削除して残りのリストを返す), maximum, sum, product
- [1..20]で簡単に１〜２０のリストを生成する。'a'..'z'も同様
  - take 24 [13,26..] こんな感じでリストを作る方が色々いい。 == [13,26..13*24]これと同じ。
    - cycle(リストを受取、その要素を無限に繰り返す。) take 10 (cycle [1,2,3]) => [1,2,3,1,2,3,1,2,3,1]
    - repeat(１つの要素を受取、その要素を無限に繰り返す) take 10 (repeat 5) => [5,5,5,5,5,5,5,5,5,5]
    - replicate(repeat をもっと簡単にできる) replicate 10 5 => [5,5,5,5,5,5,5,5,5,5]
- 内包的記法
  - 例、10以下の自然数を取ってきてそれぞれ2倍してその結果を新しい集合を求める。
    - [x*2 | x <- [1..10]]
    - 後ろにカンマで区切ることで（述語）さらに|のxに送る条件を絞ることが可能
      - [x*2 | x <- [1..10], x*2 >= 12]
    - 組み合わせリストとかも可能
      - [x+y | x <- [1,2,3], y <- [100,200,300]]
- タプルとは複数の違う方の要素を格納して（=ヘテロ）1つの値にする。リストに似てるけどちょっと違う(ヘテロなとこが違う)。ヘタレっぽい。けど全然ヘタレじゃない。
- ヘテロは()でくくる。(1,2,"hello") 
  - ''だとエラーになったけど違いがあるのかな。
  - ペアのタプルとトリプルのタプルは違う型としてみなされる。
  - (1,2) と ("one", 2) これも違う型としてみなされる。
  - タプルは要素に対する操作は中々融通が効かない。
    - fst(タプルの最初の要素を返す) fst (8, 11) => 8
    - snd(2個目の要素を返す) snd (8,11) => 11
  - zip(リスト同士を結合してタプルを返す) zip [1,2] [3,4] => [(1,3), (2,4)]

20170805

- Haskellには型推論がある。haskellはコンパイル時に既にどの型かを把握している。
  - :t を使ってghci上で確認することができる。
  - その出力結果は :: で表される。「の型を持つ」と読み替えると分かりやすい
    - :t 'a' #=> 'a' :: Char
- 関数は明示的な型宣言を与えることができる。
  - addThree :: Int -> Int -> Int -> Int
  - addThree x y z = x + y + z
- Haskellの型
  - 数値 (Int:有界の整数、Integer:有界ではない整数)
  - 単精度浮動小数点 Float型
  - 倍精度浮動小数点 Double型 ※単精度浮動小数点よりもメモリを使うが、より精度が上がる。
  - 真理値 Bool型
  - 文字列型 Chra型 ※Unicode文字列をあらわす。シングルクオートで括ってあらわす。
  - タプル型
- 型変数
  - :t head => head :: [a] -> a
    - 「任意の型リストを引数に取り、その方の要素を１つ返す」
  - このときのaを型変数と呼ぶ。どんな型も取り得るということを意味する。
  - ジェネリクスに似ている。
  - 型変数を用いた関数は多相的関数と呼ぶ。
- Eq型==,/=
  - 等値性をテストするためのインターフェースを提供する。
  - 型クラスはオブジェクト指向のクラスとは同じではないことが重要
- Ord型<,>,<=,>=
  - 何かしらの序列を付けられる型のための型クラス。
- Show型
  - Show型クラスのインスタンスになっていれば文字列として表現できる。
  - to_s 的なやつ。
  - show 3 => "3"
- Read型
  - Show型と対をなす型クラス。全てのクラスはこの型のインスタンス
  - read "True" || False => True
  - read "3" + 2 => 5
    - read "3" => これだと任意のどの型に変換すべきか推論できないためエラーとなってしまう。
  - それを防ぐ為に以下のように明示的に記述すると良い。
    - read "5" :: Int ※これがないとInt型なのかFloat型なのか推論できない。
  - Haskellは静的型付け言語なのでコンパイルする前に全ての型がわかっている必要がある。
- Enum型
  - 要素の値を列挙できる型


