20170804

Install したい。
とりあえず公式サイト見よう。
https://www.haskell.org/
Mac用のインストールガイドあった。
Homebrewあった。
https://www.haskell.org/platform/mac.html#osx-homebrewcask
`brew cask install haskell-platform`
入った。
とりあえず、対話モードで起動してみよう。
`ghci`打てばいいのか。
うまくいった。
とりあえず、「すごいHaskell」の1章読んでみる。

メモ
# はじめの一歩

## 1 − 1〜2
- プロンプトにこだわりあれば `:set prompt "ghci>"`って打つ。面倒であれば.ghci ファイルに書き込んどけば起動時に読み込む。
- 負の数は()でくくる
- 四則演算や論理演算は普通見たまま。同値演算は`==` `/=`
- 四則演算は中置演算と呼ばれるらしい。普通は前置演算。`succ 2` 3
- 関数呼び出しには優先順位があるらしい。慣れが若干必要かも
- 関数の定義は = で結ぶ。`doubleMe x = x + x`
- ファイルをghciを立ち上げたディレクトリに .hs とかで保存して :l ファイル名で呼び出せばできる。
- コメントアウトは -- で！
- Haskellにおいてif文ではelseが必須らしい。ほえ〜。
  - 関数の全ては何かしらの値を返却する。戻り値がある。なのでif文で必ずelseがあれば戻り値を期待できる。ほえ〜。
- アポストロフィは特別な意味を持たない関数名の一部として有効
- 関数名は大文字始まりは禁止。

## 1 - 3
- 数値と文字列の混合のリストは作れない。
- 変数の定義には `let` を使う。
- リストの連結操作や文字列の結合は `++` を使う。
- 文字列は内部的に文字列のリスト扱いに鳴っているのでリスト関数が文字列に適用できて便利。ほえ〜。
  - なので、文字列リスト同士の結合の戻り値は文字列で返ってくる。`['w', 'o'] ++ ['o', 'd']` => 'wood'
  - 但し、長い文字列を結合する場合とかは全リストを走査するので時間がかかる。先頭に追加するとかの処理の場合はcons演算子（:）を使う。
    - 'A':" SMALL CAT" => 'A SMALL CAT'
    - 5:[1,2,3] => [5,1,2,3]
- Haskellは遅延評価
- リストへのアクセスは `!!` 演算子を使う。
  - リストの操作 head, tail（最初の要素を取り除いた残りのリスト）, last, init(最後の要素を取り除いた残りのリスト)
  - length, null(空のリストかチェックしてbool値を返す), reverse, take(先頭から指定された数取り出す), drop(指定された数の要素を削除して残りのリストを返す), maximum, sum, product
- [1..20]で簡単に１〜２０のリストを生成する。'a'..'z'も同様
  - take 24 [13,26..] こんな感じでリストを作る方が色々いい。 == [13,26..13*24]これと同じ。
    - cycle(リストを受取、その要素を無限に繰り返す。) take 10 (cycle [1,2,3]) => [1,2,3,1,2,3,1,2,3,1]
    - repeat(１つの要素を受取、その要素を無限に繰り返す) take 10 (repeat 5) => [5,5,5,5,5,5,5,5,5,5]
    - replicate(repeat をもっと簡単にできる) replicate 10 5 => [5,5,5,5,5,5,5,5,5,5]
- 内包的記法
  - 例、10以下の自然数を取ってきてそれぞれ2倍してその結果を新しい集合を求める。
    - [x*2 | x <- [1..10]]
    - 後ろにカンマで区切ることで（述語）さらに|のxに送る条件を絞ることが可能
      - [x*2 | x <- [1..10], x*2 >= 12]
    - 組み合わせリストとかも可能
      - [x+y | x <- [1,2,3], y <- [100,200,300]]
- タプルとは複数の違う方の要素を格納して（=ヘテロ）1つの値にする。リストに似てるけどちょっと違う(ヘテロなとこが違う)。ヘタレっぽい。けど全然ヘタレじゃない。
- ヘテロは()でくくる。(1,2,"hello") 
  - ''だとエラーになったけど違いがあるのかな。
  - ペアのタプルとトリプルのタプルは違う型としてみなされる。
  - (1,2) と ("one", 2) これも違う型としてみなされる。
  - タプルは要素に対する操作は中々融通が効かない。
    - fst(タプルの最初の要素を返す) fst (8, 11) => 8
    - snd(2個目の要素を返す) snd (8,11) => 11
  - zip(リスト同士を結合してタプルを返す) zip [1,2] [3,4] => [(1,3), (2,4)]

20170805

- Haskellには型推論がある。haskellはコンパイル時に既にどの型かを把握している。
  - :t を使ってghci上で確認することができる。
  - その出力結果は :: で表される。「の型を持つ」と読み替えると分かりやすい
    - :t 'a' #=> 'a' :: Char
- 関数は明示的な型宣言を与えることができる。
  - addThree :: Int -> Int -> Int -> Int
  - addThree x y z = x + y + z
- Haskellの型
  - 数値 (Int:有界の整数、Integer:有界ではない整数)
  - 単精度浮動小数点 Float型
  - 倍精度浮動小数点 Double型 ※単精度浮動小数点よりもメモリを使うが、より精度が上がる。
  - 真理値 Bool型
  - 文字列型 Chra型 ※Unicode文字列をあらわす。シングルクオートで括ってあらわす。
  - タプル型
- 型変数
  - :t head => head :: [a] -> a
    - 「任意の型リストを引数に取り、その方の要素を１つ返す」
  - このときのaを型変数と呼ぶ。どんな型も取り得るということを意味する。
  - ジェネリクスに似ている。
  - 型変数を用いた関数は多相的関数と呼ぶ。
- Eq型==,/=
  - 等値性をテストするためのインターフェースを提供する。
  - 型クラスはオブジェクト指向のクラスとは同じではないことが重要
- Ord型<,>,<=,>=
  - 何かしらの序列を付けられる型のための型クラス。
- Show型
  - Show型クラスのインスタンスになっていれば文字列として表現できる。
  - to_s 的なやつ。
  - show 3 => "3"
- Read型
  - Show型と対をなす型クラス。全てのクラスはこの型のインスタンス
  - read "True" || False => True
  - read "3" + 2 => 5
    - read "3" => これだと任意のどの型に変換すべきか推論できないためエラーとなってしまう。
  - それを防ぐ為に以下のように明示的に記述すると良い。
    - read "5" :: Int ※これがないとInt型なのかFloat型なのか推論できない。
  - Haskellは静的型付け言語なのでコンパイルする前に全ての型がわかっている必要がある。
- Enum型
  - 要素の値を列挙できる型

20170808

- パターンマッチ
```
lucky :: Int -> String -- 型の宣言
lucky 7 = "Lucky Number Seven"
lucky x = "Sorry, you're out of luck, pal!"
```

- error関数は文字列を引数を受け取ってランタイムエラーを発生させる。
- asパターン
  - 引数の要素を分解しつつ、全体を参照することが可能。
- ガード
  - 引数の構造で場合分けをする場合にifより可読性が高い `ガード` を使うことがある。
  - case文に近い構文という認識
  - ガードの用法については body.hs:35 を参照するとよさげ。
  - if 文より可読性が高い。
  - 必ず、otherwiseで全てをキャッチするようにする。
  - 中置関数とかも baby.hs:42 とかのように定義できる。
- where
  - 計算結果を格納して変数にしまって置くことができるbaby.hs:49
  - 値に対して1度しか計算されないのでプログラムそのものが早くなることが期待できる。
  - whereのscopeその関数内からしか見えないので外から見えない。
- let 式 baby.hs:63
  - where 節によく似たもの。
  - where は関数の終わりで変数を束縛し、関数全体から見渡せる。let式はどこからでも変数を束縛でき、式にもなり得る。
  - let式が作る束縛は局所的でガード間では共有されない。
  - let式ではパターンマッチが使える。
  - let bindings in expression
- case 式
  - 変数の指定した値に対するコードブロックを評価できる。
- 再帰
  - 関数定義の中で自分自身を呼び出すこと。

- 高階関数
  - 引数として関数を撮ったり返り値として関数を返したりできる関数のこと。
  - Haskellは公式的には引数を1つだけとることになっている。
- カリー化関数
    - カリー化関数は複数の引数を受け取る代わりに、常に１つの引数を受け取る関数のこと
- 部分適用
  - 複数の引数を受け取る関数に対し、一部の引数を束縛して新しい関数を返す
- カリー化された関数であれば部分適用した関数で呼び出すことは簡単であるが、部分適用とカリー化は意味合いが異なるので注意したほうがよさそうに思った。
- セクション
  - 中置関数に対してもセクションを利用して部分適用することができる
  - 片側だけに値をおいて括弧で囲むだけ。
- ラムダ式
  - １回だけ必要な関数を作る時に使う無名関数のこと
  - 高階関数に渡す関数を作るためだけに使う。
  - \ -> で宣言する
- 関数合成
  - 1つの関数を呼び出し、それからもう一つの関数にその結果を渡して呼び出したもの。
  - . 関数を使ってそれを実現する。
- ポイントフリースタイル
  - 一時変数を取り除く書き方のこと。Rubyの `[1,2,3].map(&:+)` 的なやつかな。

- モジュール
  - 便利なモジュールは「Hackage」で探すと良いとのこと。
  - 良さそうなものを見つけたら「cabal install package 名」でインストールできる。
  - 【使い方】
    - <import モジュール名> で使えるようになる。
      - 特定の関数のみにアクセスする場合は
        - import Data.List (nub, sort)
      - 特定の関数以外をimportする場合は
        - import Data.List hiding (nub, sort)
    - GHCiからアクセスする場合は `:m + Data.List`
    - 修飾付きimport
      - 名前の競合を避ける為の方法。
      - qualifiedを使う。
        - import qualified Data.Map
        - Data.Map.filter
      - as を使う。
        - import qualified Data.Map as M
        - M.filter
